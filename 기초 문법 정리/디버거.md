### ✔️ 디버거
- 코드를 실행했을 때 자신의 의도와 다른 방식으로 코드가 진행될 수 있다.  
    - (Logic Error, 논리 오류) 
    - 그런 경우 디버거를 통해 자신이 잘못한 부분이 어딘지를 찾고 수정해야 한다.  
---    
- 아래 코드를 예시로 보자.
```csharp
	uint increasingNum = 1;
 	uint endPoint = uint.MaxValue; 
    // int는 signed형으로 부호가 존재. unsigned인 uint는 부호비트가 존재하지 않음

 	while (true)
    // 숫자가 2배가 될때 표현 가능 최댓값을 넘어서면 반복문을 탈출하는 의도로 만든 코드
 	{
     	increasingNum*=2;
     	Console.WriteLine(increasingNum);
     	if (increasingNum > endPoint)				
    	{
     	 	Console.WriteLine($"{endPoint} 초과로 종료");
       	  	break;
   	 	}
	 }
```
- 하지만 출력을 하게 되면 무한 루프로 0을 출력하게 된다.
    - 왜 늘어나야 하는데 0이 되는지, 왜 `if`문에 접근을 못하는지 ( 문제 발생 )  
- `Console.WriteLine(increasingNum);` 에 중단점을 설정하고 F10으로 결과를 지켜본다.
    - `Convert.ToString(increasingNum,2)` 해당 조사식으로 2진수로 바꾸어서 확인하면
    `uint`가 데이터를 저장하는 32비트를 넘어서 오버플로우가 발생. 
    - 그런 이유로 0이 출력되는 현상.
- `if`문에 접근하기 위해서는 `(increasingNum > endPoint)`이 참이 되어야 하는데 같은 자료형이라면 `MaxValue`를 넘을 수가 없음.
    - `long` 타입으로 `increasingNum`을 변환하면 endPoint 보다 숫자가 커질 수 있음.
    - 연산 시에 자료형이 다른 숫자끼리 연산하는 경우 상위 자료형으로 자료형이 변환됨.
- 위 예시 처럼 **중단점을 설정**해 값을 지켜보거나   
원하는 데이터를 보기 위해 **조사식을 작성**해서 직접 확인할 수 있음.
---
- 조사식
    - Convert.ToString(변수, 진법) -> 해당 진법으로 변수를 변환해서 보여줌
    - &(변수) -> 메모리 주소를 알 수 있음

- 콘솔의 입력을 받는 ReadLine과 같은 키워드가 나오면 콘솔로 자동으로 포커스가 옮겨감.
    - 입력을 정상적으로 진행해주신 후 엔터를 친 후, Visual Studio로 돌아가서 디버깅 진행.
- Rider에서는 배열을 디버깅하는 경우 배열 형태를 바로 확인 가능함.
```csharp
			int[,] arr =
			{
				{ 1, 2 },
				{ 3, 4 }
			};
```
![](https://velog.velcdn.com/images/xl5432/post/6c79e2f7-1e59-4ff4-9ef0-76eb096111cc/image.png)

---
### ✔️ 정수 표현 방법

- 2의 보수 방식으로 컴퓨터는 숫자를 기억함. 
- 2의 보수란 2진수의 숫자를 반전시킨 후 +1을 하면 해당 숫자의 음수가 되는 방식.
- signed 정수에서는 맨 앞 비트가 부호비트이고 unsigned의 경우는 부호비트가 존재하지 않음.
- 그래서 int의 경우 2배씩 증가하다가 최댓값을 초과하는 경우 부호비트가 변경되어 음수가 되는 것.

![](https://velog.velcdn.com/images/xl5432/post/fed7f441-9a5a-44d3-9c06-c60f12db8719/image.png)

---

### ✔️ 실수의 부정확함

- `float`,`double`은 부동 소수점 형식으로 실수를 표현함.
    - 표현 범위를 늘이기 위해 정확도를 일부 포기함.
    - 2진법을 사용하기 때문에 소수 표현에서 근삿값으로 표현해 오차가 발생.
    
```csharp
		float a = 13.02f ;
// 해당 값을 디버거를 통해 확인하면 정확히 13.02가 아닌 13.02의 근삿값임을 확인할수 있음.
```
- 정확한 계산을 위해서는 10진법을 사용하는 `decimal` 형을 사용해야 함.