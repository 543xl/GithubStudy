### ✔️ 배열 선언, 초기화, 크기
```csharp
string[] arr; 						// 'arr'이라는 이름의 'string[]' 배열 변수를 선언
arr = new string[4];				// 새로운 공간, 문자열 4개를 위한

string[] arr = new string[4];		// 선언과 동시에 초기화

int[] arr = { 1, 6, 2, 7, 9 }; 
// 이런 식으로도 배열 변수 선언 가능 (공간 할당 없이 바로 공간과 요소 초기화)
```
- 참조타입 변수 : 메모리 주소값을 보관하는 변수
- `null`은 메모리 주소 공간 자체가 없는 상태로 **아무 객체도 가리키지 않는 상태**
```csharp
		for (int i = 0; i < arr.Length; i++) //배열의 크기를 알기 위해서는 arr.Length
		{
			if (arr[i] % 2 == 0)
			{
				Console.WriteLine(arr[i]);
			}
		}
```

### ✔️ foreach문
```csharp
		foreach (int value in arr) 		// foreach문은 in arr을 모두 열람할 때 까지 반복
        {
        	value = 0; 		// foreach 변수는 읽기 전용이라 대입하면 컴파일 에러
            Console.WriteLine(value); 	// index 값은 알 수 없음
```
- 열람만을 위해서는 `foreach`문 / 값을 수정하기 위해서는 `for`문을 사용
- `foreach`는 배열 자체를 수정 못하는 거지 `foreach`문 안에서 다른 변수의 값은 수정가능

```csharp
foreach (int n in numbers)
{
    sum += n;							// 배열을 읽고 값을 안에서 더하는 행동 같은 경우
}
```

### ✔️	다차원 배열
```csharp
		int[,] matrix = new int[2, 3]; 	// 2행 3열의 2차원 배열 // , 개수에 따라 차원 결정
        
        int[,] matrix =
        {
			{ 6, 17, 8 },
			{ 16, 28, 2 }
		};								// 공간 할당과 대입을 동시에 하는 방법
        
        Console.WriteLine(matrix[1, 2]); 
        // 2번째 행, 3번째 열에 있는걸 출력해줘. index는 0부터 시작이니까!
```
- index가 0부터 시작한다는 사실이 중요.
- 차원의 개수를 구할때도 같음.
```csharp
		for (int i = 0; i < matrix.GetLength(0); i++) 
        // matrix 생성 시 첫번째 차원의 길이 // new int[2, 3] <- [첫번째 차원, 두번째 차원]
		{
			for (int j = 0; j < matrix.GetLength(1); j++) 	
            // 1차원은 3, 즉 두번째 차원의 길이
			{
				Console.WriteLine(matrix[i,j] + "\t");	// \t는 escape sequence 가로탭
			}
			Console.WriteLine();
		}													// 배열을 형태대로 출력
```
### ✔️ 문자열
```csharp
		string text = "희희희희희희";  	// string은 char로 이루어진 문자열
		Console.WriteLine(text[1]);		// string의 경우 수정이 불가능. 출력은 가능
        
        char[] chars = text.ToCharArray(); 
        // 문자열의 수정을 위해서는 char 배열로 변환해야 함 
		chars[1] = 'ㅎ';
        
        string text2 = new string(chars); // 다시 string으로 변환
        
        Console.WriteLine(text2);	// char형일 때 변환된 글자가 수정되어 문자열로 출력
```
- 입력은 첫 줄에 공백으로 구분하여 주어진다는 문구가 문제에 시작에 주로 있음.
```csharp
		string[] inputs = Console.ReadLine().Split(' ');
        // 여러 개의 값을 공백으로 나누어 문자열 배열로 받아오는 기능
        // a b 이런식으로 공백으로 입력하면 두 변수가 자동으로 입력되는 형식
        // Split이 필요한 크기의 새 배열을 만들어서 inputs에 넣어준 것. 공간 할당 따로 X
        int a = int.Parse(inputs[0]);
		int b = int.Parse(inputs[1]);  		// 숫자라면 int.Parse로 변환
```
---
### ✔️ 함수 기본 내용
- `Main`은 앞에 `static`이 붙어 있는 함수를 바로 호출할 수 있음
- 함수는 `main` 밖에서 작성하고 `main`에서 불러오는 형식
- 함수의 **이름을 잘 지어야** 함수 사용 시 **가독성 좋음**
### ✔️ 반환값 X, 인자값 X
```csharp
		static void PrintMyName()		// void는 반환값이 없을 때
		{
			Console.WriteLine("제 이름은");
			Console.WriteLine("이종현");
			Console.WriteLine("입니다");
		}								// 함수 실행 시 그냥 함수 내용 실행
```
### ✔️ 반환값 X, 인자값 O
```csharp
		static void Sum(int a, int b) 	// a, b 를 인자값으로 입력하는 경우
        {
			int result = a + b;
			Console.WriteLine(result);	// 함수 자체에서만 계산 실행 및 출력
            // main에 값을 전달하지는 않음
		}
```
### ✔️ 반환값 O, 인자값 X
```csharp
		// 반환 시에는 자료형이 void가 아니라 함수에서 원하는 자료형이어야 함
        static int GetOne()				// 인자값 없이 함수 데이터만을 반환하는 것
		{
			int result = 1;
			Console.WriteLine("1을 반환합니다");
			return result;
		}
        
        // main에 적용 시 
        int a = GetOne();
		Console.WriteLine(a);  			
        // 출력 시 int a 변수 선언 없이 그냥 GetOne 자체 를 인자값에 넣어서 출력해도 가능
        Console.WriteLine(GetOne());
        // 함수 선언부에 이미 명시되어 있기 때문
```
### ✔️ 반환값 O, 인자값 O
```csharp
		// a와 b를 인자로 받고, 두 수의 합을 반환함
		static int Sum(int a, int b)
		{
			Console.WriteLine($"{a} + {b} 값을 반환합니다");
			return a + b;
		}
        
        // main에 적용 시 
        int result = Sum( a, b);
        Console.WriteLine(result);
        
```
### ✔️ 매개변수 한정자 ref, in, out 

- 값 복사에 의한 함수 호출 Call by Value. (원본 x, 복사본 O)
- 이 상태로 함수를 불러올 경우 함수내에서만 적용되고 원본은 변하지 않음
```csharp
        static void SwapTwoNum1(int a, int b)
		{
			int temp = a;
			a = b;
			b = temp;
		}	
```        

#### ref

- 참조에 의한 함수 호출 Call by Reference. 
- 원본 메모리 주소 값을 전달받아 원본을 직접 변경함 
```csharp
        static void SwapTwoNum2(ref int a, ref int b) //함수만 적용해도 원본 정상 작동
		{
			int temp = a;
			a = b;
			b = temp;
		}
```
#### out

- `out` 키워드가 붙은 인자에는 반드시 값을 할당해야 한다.
- `TryParse`와 동일한 경우. 
- `input`을 받아서 `out`으로 내보내고 `bool` 타입의 정보를 반환하는 점.
```csharp
		static bool TryGetIntValue(out int value) 
		{
			string input = Console.ReadLine();
			return int.TryParse(input, out value);
		}
        
        // main에 적용 시
        int number;   // 여기에서 변수 선언됨 (초기화는 안됨)
   		bool success = TryGetIntValue(out number);
        // 빈 메모리 공간을 주면, 함수가 데이터를 채워서 반환
     	// main이 직접 입력을 받는 것이 아닌 입력 받는 기능이 있는 함수를 호출하는 것
```

#### in
- `in` 키워드가 붙은 인자는 읽기 전용이므로 값 수정이 불가능
- 참조 전달로 함수에 대입되고 `bool` 타입 데이터만 반환
```csharp
		static bool IsEvenNum(in int value)
		{
			if (value % 2 == 0)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
        
        // main에 적용 시
        int number = 10 ; 	// 여기에서 변수 선언과 초기화 됨
   		bool success = IsEvenNum(in number);
        
```
### ✔️ 함수 인자로 배열 대입
```csharp
		// arr을 전달 → 참조타입이므로 함수 안에서 직접 arr 내용 변경 가능
		static void SwapArr(int[,] arr, int a, int b, int c, int d)
        {
        	int temp = arr [a - 1, b - 1];
            arr [a - 1, b - 1] = arr [c - 1, d - 1];
			arr [c - 1, d - 1] = temp;
		}
        
        // main에서 적용 시
        int[,] arr = 
         {
			{ 6, 17, 8 },
			{ 16, 28, 2 },
            { 6, 17, 8 },
			{ 16, 28, 2 }
		};	
        SwapArr(arr, 1, 4, 2, 3); 			// 인자 앞에 타입을 쓰면 안 됨
       								 		// 배열 재선언 X, 값만 교체 O
        for ( int i = 0; i < arr.GetLength(0); i++ )	// 배열 형태대로 출력
        {
        	for ( int j = 0; j < arr.GetLength(1); j++ )
            {
            	Console.Write(arr[i, j] + " ");
			}
            Console.WriteLine();
        }    
```